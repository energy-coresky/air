#.yaml ///////////////////////////////////////////////////////////////////////////////////////
#._
+ @inc(.) ~/assets/database.yaml
#._

# ////////////////////////////////////////////////////////////////////////////////////////////
#.nice_php ///////////////////////////////////////////////////////////////////////////////////
body:
  rules:
    + @inc(.tag_rules)  # <? ?>
    + @inc(.multilines) # <div, "A\nB"
    + @inc(.elseifelse) # elseif else
    + @inc(.endwords)   # endif,..
    + @inc(.casecolon)  # : switch case default
    + @inc(.chars)      # . ; & ? =
    + @inc(.comments)   # //,..
    - on: in_array($y->tok ?: $y->str, $this->_ws_both, true) # + - += -= => ..
      do: $line .= $ws($y);
    + @inc(.ctrl_mains) # for,.. if catch echo match
    + @inc(.brackets)   # {[(,)]}
    default: |
      if ($line !== '' && $alfa($line[-1]) && $alfa($y->str[0]))
          $line .= ' ';
      $line .= $y->str;
head:
  param: $at, $to = 0
  code: |
    $depth = $dar = $d1 = $d2 = $s3 = $s5 = $q7 = $q8 = $in_php = $reason = 0;
    $out = $line = $last_mod = '';
    $ifs = [];
    $stk =& $this->stack;

    $put = function (...$in) use (&$out, &$line, &$depth) {
        if (is_int($in[0]))
            $depth += array_shift($in);
        [$s1, $s2] = $in + ['', ''];
        '' === $s1 or $out .= $line . $s1;
        $line = str_pad('', $depth * $this->tab) . $s2;
    };
    $ws = function ($y) use (&$line) {
        return $line === '' || ' ' == $line[-1] ? "$y->str " : " $y->str ";
    };
    $ok_com = function ($y) use (&$out) {
        $pos = strrpos($out, "\n", -2);
        if (!$len = strlen(trim(substr($out, $pos)))) # empty prev line
            return false;
        return $len + strlen($y->str) < 90 && $len > 3;
    };
    $reset_ifs = function ($y) use (&$ifs, &$depth, &$d1, &$d2) {
        if (in_array($y->tok, [T_ELSE, T_ELSEIF, T_FINALLY]))
            return; // ';' == $y->str || 
        array_splice($ifs, $d2);
        [$depth, $d1] = [$depth - $d1, 0];
    };
    $get_exp = function ($y) {
        $cnt = $y->len ? $y->cnt : [];
        return (object)[
            'len' => $y->len ? ($y->close < 1 ? $y->len : 0) : 0,
            'cnt' => $cnt + ['?' => 0, '.' => 0, '-' => 0],
        ];
    };

    $calc_max = function ($len) use (&$depth) {
        $max = $this->max_length - $depth * $this->tab;
        $max > 10 or $max = 10;
        return ceil($len / ceil($len / $max)) + $depth * $this->tab;
    };
    $alfa = fn($chr) => preg_match("/[a-z_\d\$]/i", $chr);
    $fnew = fn($y) => is_int($y) ? $this->tok($y, true) : ($y->new->com ? $this->tok($y->new->i, true) : $y->new);

    for ($y = $pv = $pv_nc = $this->tok($at); $y; $y = $y->new) {
        if (($y->new = $this->tok($y->i + 1)) && T_WHITESPACE == $y->new->tok)
            $y->new = $this->tok($y->i + 2); # next is NOT WHITESPACE
        if ($y->new && ($y->new->com = in_array($y->new->tok, $this->_comments))) {
            $c2 = $y->new->str[1] ?? '#';
            $y->new->com = '[' == $c2 ? 5 : ('*' == $c2 && '/' == $y->new->str[0] ? 2 : 1); # (->com & 1) - is nl required
            $y->new->str = rtrim($y->new->str); # (->com == 5) - attribute, nl required
            if (2 == $y->new->com && (strpos($y->new->str, "\n") || '' === $line))
                $y->new->com = 3; # multiline comment
        }
        $oc = $this->int_bracket($y, true);
        if ($y->len && $y->close < 1 || !isset($exp))
            $exp = $get_exp($y);
        if ($this->in_str) {
            $line .= $y->str;
            continue;
        }
            
        if (T_RETURN == $y->tok && ';' != $y->new->str)
            $y->str .= ' ';
        if (')' == $pv->str && in_array($y->tok, [T_USE, T_AS]))
            $y->str = " $y->str ";

        if (in_array($y->tok, [T_CATCH, T_FINALLY])
            || T_WHILE == $y->tok && $pv->len && T_DO == $pv->reason
            || ')' == $pv->str && in_array($y->tok, $this->_no_nl_after, true)
            ) {
            $y->str = ' ' . $y->str;
        } elseif (T_WHILE == $y->tok && '}' == $pv->str) {
            $put("\n");
        } elseif ('}' == $pv->str && $pv->len && !in_array($y->tok ?: $y->str, $this->_not_nl_after_curly)) {
            $put(in_array($pv->reason, $this->_double_nl_after) ? "\n\n" : "\n");
        }

        if ($y->len && $y->reason) {
            in_array($reason = $y->reason, $this->_double_nl_after) or $last_mod = '';
        }
        if (in_array($reason, $this->_double_nl_after) && in_array($pv_nc->str, [';', '{']) && in_array($y->tok, $this->_semicolon_prev)) {
            !$last_mod or $last_mod == $y->tok or $line = '' or $put("\n");
            $last_mod = $y->tok;
        }

tail:
  code: |
    unset($new);
    $pv = $y;
    $y->com or $pv_nc = $y;
    }
    return $out . $line . ($in_php ? "\n" : '');
#.nice_php

#.ary_nice_php ///////////////////////////////////////////////////////////////////////////////////
+ @preflight |
  $array['not_nl_curly'] = [ # step1,2
    T_NULLSAFE_OBJECT_OPERATOR => T_OBJECT_OPERATOR,
    T_NAME_QUALIFIED => T_NS_SEPARATOR,
  ];
  foreach ($array as $key => $val)
      PHP::$data->{$key} = $val;

tokens_ign: [$T_WHITESPACE, $T_COMMENT, $T_DOC_COMMENT] # step1
curly_reason: [ # step1
  $T_DECLARE, $T_NAMESPACE, $T_USE, $T_SWITCH, $T_MATCH, $T_DO,     $T_FN,
  @@inc(.loops), @@inc(.ifels), @@inc(.newdn), @@inc(.try),         $T_OBJECT_OPERATOR, $T_NS_SEPARATOR
]
optim_key: [ # step1
  @@inc(.com3), $T_WHITESPACE, $T_VARIABLE,
  $T_LNUMBER, $T_DNUMBER, $T_CONSTANT_ENCAPSED_STRING
]
not_nl_after_curly: [
  ',', '(', ')', ']', '}', ;,
  $T_CATCH, $T_FINALLY, $T_ELSE, $T_ELSEIF
]
ws_tail: [@@inc(.loops), $T_IF, $T_CATCH, $T_ECHO, $T_MATCH]
ws_both: [
  /, %, *, >, <, +, $T_DOUBLE_ARROW, $T_POW,
  @@inc(.logic), @@inc(.bools), @@inc(.op_eq), @@inc(.op_is), @@inc(.shift)
]
semicolon_prev: [@@inc(.modifiers), $T_CONST, $T_USE, $T_FUNCTION]
double_nl_after: [@@inc(.newdn), $T_NAMESPACE]
ctrl_d1: [@@inc(.loops), $T_IF]
multilines: [$T_INLINE_HTML, $T_CONSTANT_ENCAPSED_STRING]
comments: @inc(.com3)
endword: @inc(.ends)
altsyntax: [@@inc(.loops), $T_IF, $T_ELSEIF, $T_SWITCH, $T_DECLARE, $T_CASE, $T_DEFAULT]
expr_reset: [@@path(altsyntax), $T_ELSE, $T_FUNCTION]
no_nl_after: [$T_TRY, $T_DO, $T_SWITCH, $T_MATCH, '{', ';', ':']
no_nl_after_else: [@@path(no_nl_after), @@inc(.loops), $T_IF]
minus: [@@path(ws_both), ., '[', '(', ',', ':', '?']
#.ary_nice_php

# =====================================================================================
# ================================           RULES           ==========================
# =====================================================================================
#.tag_rules
- on: T_OPEN_TAG == $y->tok
  do: |
    $y->i ? ($line .= $y->str) : $put(trim($y->str) . "\n\n") or $y->len = 0;
    $in_php = true;
- on: T_CLOSE_TAG == $y->tok
  do: |
    '' === $line || ' ' == $line[-1] or $y->str = " $y->str";
    if ("\n" == $y->str[-1]) {
        $put($y->str);
    } else {
        $y->new ? ($line .= $y->str) : $put("\n\n" . trim($y->str));
    }
    $in_php = false;
- on: T_HALT_COMPILER == $y->tok
  do: |
    $line .= $y->str;
    $in_php = false;
    $this->in_html = 1;
#.tag_rules

#.multilines
- on: in_array($y->tok, $this->_multilines)
  do: |
    if (T_INLINE_HTML == $y->tok)
        $this->in_html = $y->i;
    if (false !== ($pos = strrpos($y->str, "\n"))) {
        $put(substr($y->str, 0, $pos + 1));
        $line = substr($y->str, $pos + 1);
    } else {
        $line .= $y->str;
    }
#.multilines

#.elseifelse
- on: ($else = T_ELSE == $y->tok) || T_ELSEIF == $y->tok
  do: |
    $new = $fnew($y);
    $else or $new = $fnew($close = $new->close);
    $alt = ':' == $new->str;
    $prev = $depth;
    [$depth, $d1, $d2] = $alt || $else ? array_pop($ifs) : end($ifs);

    if ($this->in_html) {
        $line .= $else ? $y->str : "$y->str ";
    } else {
        $no_nl = $alt ? false : in_array(
            $new->tok ?: $new->str,
            $else ? $this->_no_nl_after_else : $this->_no_nl_after,
            true
        );
        if ('}' == $pv->str && ($depth < $prev || !$no_nl))
            $put("\n");
        if ($alt) { # altsyntax
            $put('' === trim($line) ? '' : "\n", $else ? $y->str : "$y->str ");
        } elseif ($no_nl) {
            '' === trim($line) ? $put('') : ($line .= ' ');
            $line .= $else && !$new->tok ? $y->str : "$y->str ";
        } elseif ($else) {
            $put('' === trim($line) ? '' : "\n", $y->str);
            $d1++;
            $put(1, "\n");
        } else { # T_ELSEIF
            '' === trim($line) ? $put('', "$y->str ") : ($line .= "$y->str ");
            $dar = $close;
        }
    }
#.elseifelse

#.endwords
- on: in_array($y->tok, $this->_endword)
  do: |
    [$depth, $d1, $d2] = array_pop($ifs);
    if (T_ENDIF == $y->tok)
        array_pop($ifs);
    if ($this->in_html) {
        $line .= $y->str;
    } else {
        $put('' === trim($line) ? '' : "\n", $y->str);
    }
#.endwords

#.casecolon
- on: in_array($y->tok, [T_SWITCH, T_CASE, T_DEFAULT])
  do: |
    if (T_SWITCH == $y->tok) {
        $line .= $y->str . ' ';
    } else {
        $s3 = true;
        $s5 ? $put(-1, '', $y->str) : ($line .= $y->str);
        T_DEFAULT == $y->tok or $line .= ' ';
    }
    $s5 = 0;
- on: ':' == $y->str
  do: |
    if ($q8 == count($stk)) {
        $put("\n", ': ');
        [$q8] = [0, $depth--, $d1--];
    } elseif ($s3) {
        $s3 = false;
        $put($s5 = 1, ":\n");
    } elseif (T_ELSE == $pv->tok) {
        goto altelse; # ELSE:
    } elseif (')' == $pv->str) {
        if (in_array($pv->reason ?? 0, $this->_altsyntax)) {
            altelse:
            $ifs[] = [$depth, $d1, $d2];
            [$d1, $d2] = [0, count($ifs)];
            $this->in_html ? ($line .= ':') : $put(1, ":\n");
        } else {
            $line .= ' : ';
        }
    } else {
        $line .= '?' == $pv->str ? ': ' : ' : ';
    }
#.casecolon

#.chars
- on: T_OBJECT_OPERATOR == $y->tok
  do: |
    if ($exp->cnt['-'] > 1) {
        $put("\n", $y->str);
    } else {
        $line .= $y->str;
    }
- on: '?' == $y->str
  do: |
    if (!$exp->cnt['?'] || $exp->len < $this->max_length) { //$y->len + strlen($line)
        $line .= ':' == $y->new->str ? ' ?' : ' ? ';
    } else {
        $exp->len = 0;
        $d1++;
        $put(1, "\n", '? ');
        $q8 = count($stk);
    }
- on: '.' == $y->str
  do: |
    $len = 3 + strlen($line . $y->new->str);
    $new = $y->new->len && $y->new->close ? $y->new : $fnew($y->new->i);
    if ($new->len && $new->close && $len + $new->len > $this->max_length && $new->len < $this->max_length)
        $len = $this->max_length;
    if ($len < $this->max_length) {
        $line .= $ws($y);
    } else {
        $q7 or [$q7] = [++$d1, ++$depth];
        $put("\n", '. ');
    }
- on: ';' == $y->str
  do: |
    $q7 = $exp->len = 0;
    if ($this->in_html || $this->in_par) {
        $line .= '; ';
    } else {
        $d1 && $y->new && $reset_ifs($fnew($y));
        $put(";\n");
    }
- on: '&' == $y->str
  do: |
    if ($alfa($pv->str[-1]))
        $y->str = ' ' . $y->str;
    if ($alfa($y->new->str[0]) && T_FUNCTION != $pv->tok && (T_VARIABLE != $y->new->tok || '=' == $pv->str))
        $y->str .= ' ';
    $line .= $y->str;
- on: '=' == $y->str
  do: |
    $line .= ' =' . ('&' == $y->new->str ? '' : ' ');
- on: '-' == $y->str
  do: |
    $line .= in_array($pv->str, $this->_minus) ? '-' : ' - ';
#.chars

#.comments
- on: $y->com
  do: |
    if ($at && 1 & $y->com)
        return [$y, str_pad('', $this->max_length)];
    if ('' === trim($line) && !$pv->com && (!$y->new || !in_array($y->new->tok, $this->_comments)) && $ok_com($y)) {
        $out = substr($out, 0, -1) . " $y->str\n";
        $put('');
    } elseif (1 & $y->com || T_DOC_COMMENT == $y->tok) { # new line
        $put("$y->str\n");
    } else {
        $line .= $y->str;
    }
#.comments

#.ctrl_mains
- on: in_array($y->tok, $this->_ws_tail)
  do: |
    $line .= $y->str . " ";
    if (in_array($y->tok, $this->_ctrl_d1)) {
        if (T_IF == $y->tok)
            $ifs[] = [$depth, $d1, $d2];
        $new = $fnew($dar = $fnew($y)->close);
        if (in_array($new->tok ?: $new->str, $this->_no_nl_after, true))
            $dar = 0;
    }
#.ctrl_mains

#.brackets
- on: $oc || ',' == $y->str
  do: |
    if ($at) {
        if ($oc > 0) { # open
            if ($y->len > 80 || '{' == $y->str)
                return [$y, $out . $line];
        } elseif ($y->i >= $to) { # close or comma
            return [$y, $out . $line];
        }
        $line .= $y->str . ($oc ? '' : ' ');
    } else {
        if ('(' == $y->str && in_array($pv->tok, $this->_altsyntax)) {
            [,, $_reason, $close] = $this->x[$y->i];
            $this->x[$close] = [0, 0, $_reason, $close];
        } elseif (')' == $y->str && $q7) {
            [$q7] = [0, $depth--, $d1--];
        }
        if (',' == $y->str) { # comma
            $top =& $stk[array_key_last($stk)];
            top:
            if (!$top[0]) {
                $line .= ', ';
            } elseif (true === $top[0]) {
                if ($q7)
                    [$q7] = [0, $depth--, $d1--];
                $put(",\n");
                $exp = $get_exp($y);
            } elseif (1 == $top[0]) {
                strlen($line) < $top[2] ? ($line .= ', ') : $put(",\n");
            } elseif ('[' != $top[2] || $top[0] < 10) {
                $top[0] = '{' != $top[2];
                goto top;
            } else {
                $top = [1, $top[1], $calc_max($top[3])];
                goto top;
            }
        } else {
            $y->line =& $line;
            $_depth = $depth;
            $this->indents($oc, $y, $pv->tok, $put, $exp);
            if ($oc > 0)
                $exp = $get_exp($y);
        }
        if ($dar == $y->i) { # )
            $put(1, "\n");
            $d1++;
        } elseif ('{' == $y->str && $_depth != $depth) {
            $last_mod = '';
            $ifs[] = [$_depth, $d1, $d2];
            [$d1, $d2] = [0, count($ifs)];
        } elseif ('}' == $y->str && $_depth != $depth) {
            $last_mod = '';
            [$depth, $d1, $d2] = array_pop($ifs);
            in_array($y->reason, [T_TRY, T_DO]) or $y->new && $reset_ifs($fnew($y));
        }
    }
#.brackets
