# ////////////////////////////////////////////////////////////////////////////////////////////
#.nice_php ///////////////////////////////////////////////////////////////////////////////////
body:
  rules:
    + @inc(.tag_rules)
    + @inc(.casecolon)
    + @inc(.semicolon)
    + @inc(.ampersand)
    + @inc(.question)
    + @inc(.equal)
    + @inc(.whitespace_after)
    + @inc(.whitespace_both)
    + @inc(.comments)
    - on: $oc || ',' == $y->str
      do: |
        if ($at) {
            if ($oc > 0)
                return [$y, $out . $line];
            $line .= ',' == $y->str ? ', ' : $y->str;
        } else {
            $y->line =& $line;
            $line .= $this->open_close($oc, $y, $pv->tok ?: $pv->str, $depth, $put);
            if ($dar == $y->i) {
                $depth++;
                $put("\n");
                $d1 = 1;
            }
        }
    - on: null
      do: |
        isset($pv->com) or $pv->com=0;
        if (!$pv->com && $alfa($pv->str[-1]) && $alfa($y->str[0]) || T_RETURN == $pv->tok)
            $line .= ' ';
        $line .= $y->str;
head:
  param: $at
  code: |
    $depth = $dar = $d1 = $d2 = $in_php = $case = 0;
    $out = $line = $last_pv_semi ='';
    $put = function ($s1, $s2 = '') use (&$out, &$line, &$depth) {
        '' === $s1 or $out .= $line . $s1;
        $line = str_pad('', $depth * $this->tab) . $s2;
    };
    $alfa = fn($chr) => preg_match("/[a-z_\d\$]/i", $chr);

    for ($y = $pv = $this->tok($at); $y; $y = $y->new) {
        $y->new = $this->tok($y->i + 1);
        if (T_WHITESPACE == $y->tok)
            continue;
        if ($y->com = in_array($y->tok, $this->_comments)) {
            $c2 = $y->str[1] ?? '#';
            $y->com = '[' == $c2 ? 5 : ('*' == $c2 && '/' == $y->str[0] ? 2 : 1); # (->com & 1) - is nl required
            $y->str = rtrim($y->str); # (->com == 5) - attribute
            if (2 == $y->com && strpos($y->str, "\n"))
                $y->com = 1;
        }
        if ($at && strlen($out . $line) > 120)/////////
            return [$y, $out . $line];
        $oc = $this->bracket($y);
        if ($this->in_str) {
            $line .= $y->str;
            continue;
        }
        if (in_array($y->tok, $this->_ws_head)) {
            $y->str = ' ' . $y->str;
        }
        if ('}' == $pv->str && isset($pv->reason) && !in_array($y->tok ?: $y->str, $this->_not_nl_after_curly)) {
            $put(in_array($pv->reason, $this->_double_nl_after) ? "\n\n" : "\n");
        }
        if (';' == $pv->str && in_array($y->tok, $this->_semicolon_prev)) {
            $last_pv_semi == $y->tok or $line = '' or $put("\n");
            $last_pv_semi = $y->tok;
        }
tail:
  code: |
    //$y->com or 
    $pv = $y;
    }
    return $out . $line . ($in_php ? "\n" : '');
#.nice_php


~
# =====================================================================================
#.loops ==========================     ALL TOKENS SORTED     ==========================
# =====================================================================================
+ [$T_FOR, $T_FOREACH, $T_WHILE]
#.loops.ifels
+ [$T_IF, $T_ELSEIF, $T_ELSE]
#.ifels.modifiers
+ [$T_VAR, $T_PUBLIC, $T_PROTECTED, $T_PRIVATE, $T_STATIC, $T_ABSTRACT, $T_FINAL, $T_READONLY]
#.modifiers.sets
+ [$T_PUBLIC_SET, $T_PROTECTED_SET, $T_PRIVATE_SET] # хуки свойств (доступно с PHP 8.4.0)
#.sets.try
+ [$T_TRY, $T_CATCH, $T_FINALLY]
#.try.casts
+ [$T_ARRAY_CAST, $T_BOOL_CAST, $T_DOUBLE_CAST, $T_INT_CAST, $T_OBJECT_CAST, $T_STRING_CAST, $T_UNSET_CAST]
#.casts.magic
+ [$T_DIR, $T_FILE, $T_LINE, $T_NS_C, $T_FUNC_C, $T_CLASS_C, $T_TRAIT_C, $T_METHOD_C]
#.magic.inc
+ [$T_INCLUDE, $T_INCLUDE_ONCE, $T_REQUIRE, $T_REQUIRE_ONCE]
#.inc.op_eq
+ [
  $T_PLUS_EQUAL, $T_MINUS_EQUAL, $T_DIV_EQUAL, $T_MOD_EQUAL, $T_MUL_EQUAL, $T_POW_EQUAL,
  $T_AND_EQUAL, $T_OR_EQUAL, $T_XOR_EQUAL, $T_COALESCE_EQUAL, $T_CONCAT_EQUAL, $T_SL_EQUAL, $T_SR_EQUAL
]
#.op_eq.op_is
+ [
  $T_IS_EQUAL, $T_IS_NOT_EQUAL, $T_IS_IDENTICAL, $T_IS_NOT_IDENTICAL,
  $T_IS_GREATER_OR_EQUAL, $T_IS_SMALLER_OR_EQUAL, $T_COALESCE, $T_SPACESHIP
]
#.op_is.op_obj
+ [$T_OBJECT_OPERATOR, $T_NULLSAFE_OBJECT_OPERATOR] # ?-> классы и объекты
#.op_obj.ends
+ [$T_ENDIF, $T_ENDFOR, $T_ENDFOREACH, $T_ENDSWITCH, $T_ENDWHILE, $T_ENDDECLARE]
#.ends.names8
+ [$T_NAME_FULLY_QUALIFIED, $T_NAME_QUALIFIED, $T_NAME_RELATIVE]
#.names8.inside A STRING
+ [$T_NUM_STRING, $T_STRING_VARNAME, $T_CURLY_OPEN, $T_DOLLAR_OPEN_CURLY_BRACES, $T_ENCAPSED_AND_WHITESPACE]
#.inside.typedef FOLLOWED: fn(&$r) => $r =& $x; NOT: public int|(A&B) $q = 1 & 0;
+ [$T_AMPERSAND_FOLLOWED_BY_VAR_OR_VARARG, $T_AMPERSAND_NOT_FOLLOWED_BY_VAR_OR_VARARG] # & Объявления типов (доступно с PHP 8.1.0)
#.typedef.newdn
+ [$T_INTERFACE, $T_CLASS, $T_TRAIT, $T_ENUM, $T_FUNCTION] # enum from 8.1
#.newdn.bools
+ [$T_BOOLEAN_AND, $T_BOOLEAN_OR] # && ||
#.bools.logic
+ [$T_LOGICAL_AND, $T_LOGICAL_OR, $T_LOGICAL_XOR]
#.logic.shift
+ [$T_SL, $T_SR] # >> <<
#.shift.words
+ [
  $T_EXIT, $T_RETURN, $T_YIELD, $T_YIELD_FROM, $T_FN, $T_ARRAY, $T_EXTENDS, $T_IMPLEMENTS,
  $T_GLOBAL, $T_GOTO, $T_NEW, $T_HALT_COMPILER, $T_INSTANCEOF, $T_INSTEADOF, $T_DECLARE,
  $T_ISSET, $T_UNSET, $T_LIST, $T_EMPTY, $T_EVAL, # isset() unset() list() empty() eval()
  $T_DO, $T_AS, $T_CONTINUE, $T_BREAK, $T_DEFAULT, $T_CASE, $T_SWITCH, $T_MATCH, # match (доступно с PHP 8.0.0)
  $T_ECHO, $T_PRINT, $T_THROW,
  $T_CALLABLE, $T_CLONE
]
#.words.here
+ [$T_START_HEREDOC, $T_END_HEREDOC]
#.here.comment
+ [$T_COMMENT, $T_DOC_COMMENT, $T_ATTRIBUTE] ### // # /* */ #[ attributes (PHP 8.0)
#.comment.id
+ [$T_INC, $T_DEC]
#.id.tags
+ [$T_OPEN_TAG, $T_OPEN_TAG_WITH_ECHO, $T_CLOSE_TAG] # <?php <? или <%, <?= или <%=, ?> или %>
#.tags.other
+ [                                # ::(T_DOUBLE_COLON=T_PAAMAYIM_NEKUDOTAYIM), =>(T_DOUBLE_ARROW)
  $T_WHITESPACE, $T_STRING, $T_VARIABLE, $T_INLINE_HTML, $T_USE, $T_DOUBLE_COLON, $T_DOUBLE_ARROW,
  $T_NS_SEPARATOR, $T_ELLIPSIS, # ... аргументы функции
  $T_CONSTANT_ENCAPSED_STRING, # "foo" или 'bar' строка
  $T_CONST,
  $T_POW, # **
  $T_NAMESPACE,
  $T_LNUMBER, # 123, 012, 0x1ac и т.д.  целые числа
  $T_DNUMBER, # 0.12 и т.д. числа с плавающей точкой
  $T_BAD_CHARACTER, # все, что ниже ASCII 32 исключая \t (0x09), \n (0x0a) и \r (0x0d)
]
#.other

#.nice_php_array ///////////////////////////////////////////////////////////////////////////////////
+ @preflight |
  $array['not_open_curly'] = [
    T_NULLSAFE_OBJECT_OPERATOR => T_OBJECT_OPERATOR,
    T_NAME_QUALIFIED => T_NS_SEPARATOR,
  ];

#nl_head: [@@inc(.loops), $T_IF, $T_SWITCH, $T_MATCH, $T_LIST, $T_DO]
not_nl_after_curly: [',', ')', ']', '}', ;, $T_ELSE, $T_ELSEIF]
ws_head: [$T_ELSE, $T_CATCH]
ws_tail: [@@inc(.loops), $T_IF, $T_CATCH, $T_ECHO, $T_MATCH, $T_LIST, $T_DO]
ws_both: [
  @@inc(.logic), @@inc(.bools), @@inc(.op_eq), @@inc(.op_is), @@inc(.shift),
  $T_DOUBLE_ARROW, $T_ELSEIF,
  /, %, *, ., >, <, +, -
]
semicolon_prev: [@@inc(.modifiers), $T_CONST, $T_USE, $T_FUNCTION]
double_nl_after: [@@inc(.newdn), $T_NAMESPACE]
control: [$T_IF, @@inc(.loops)]
comments: @inc(.comment)

curly_reason: [
  $T_DECLARE, $T_NAMESPACE, $T_USE, $T_SWITCH, $T_MATCH, $T_DO,
  @@inc(.loops), @@inc(.ifels), @@inc(.newdn), @@inc(.try)
]
#.nice_php_array

# =====================================================================================
#.loops ==========================           RULES           ==========================
# =====================================================================================
#.tag_rules
- on: T_OPEN_TAG == $y->tok
  do: |
    $in_php = true;
    $y->i ? ($line .= "$y->str ") : $put(trim($y->str) . "\n\n");

- on: in_array($y->tok, [T_HALT_COMPILER, T_CLOSE_TAG])
  do: |
    $line .= $y->str;
    $in_php = false;
#.tag_rules

#.question
- on: '?' == $y->str
  do: |
    ':' == $y->new->str ? ($line .= ' ?') : ($line .= ' ? ');
#.question

#.casecolon
- on: ($x = ':' == $y->str) || in_array($y->tok, [T_SWITCH, T_CASE, T_DEFAULT])
  do: |
    if ($case) { # colon
        $case = 0;
        $d2 = ++$depth;
        $put(":\n");
    } elseif ($x) { # colon also
        $line .= '?' == $pv->str ? ': ' : ' : ';
    } elseif (T_SWITCH == $y->tok) {
        $line .= $y->str . ' ';
        $d2 = 0;
    } else {
        $case = 2;
        if ($d2) {
            $depth--;
            $put('', $y->str);
        } else {
            $line .= $y->str;
        }
        T_DEFAULT == $y->tok or $line .= ' ';
        $d2 = 0;
    }
#.casecolon

#.semicolon
- on: ';' == $y->str
  do: |
    if ($d1 == 1) {
        $d1 = 0;
        $depth--;
    }
    $this->in_par ? ($line .= "; ") : $put(";\n");
#.semicolon

#.ampersand
- on: '&' == $y->str
  do: |
    $new = $this->tok($y->i, true);
    if ($alfa($pv->str[-1]))
        $y->str = ' ' . $y->str;
    if ($alfa($new->str[0]) && T_FUNCTION != $pv->tok && 
        (T_VARIABLE != $new->tok || '=' == $pv->str)
    )
        $y->str .= ' ';
        
    
        $line .= $y->str;
        //T_FUNCTION == $pv->tok ? ' &' : ('=' == $pv->str ? '& ' : '&');
    
#.ampersand

#.equal
- on: '=' == $y->str
  do: |
    $new = $this->tok($y->i, true);
    $line .= " =" . ('&' == $new->str ? '' : ' ');
#.equal

#.whitespace_after
- on: in_array($y->tok, $this->_ws_tail)
  do: |
    $line .= $y->str . ' ';
    if (in_array($y->tok, $this->_control)) {
        $dar = $this->get_close($y, $y->new);
        if (in_array($this->tok($dar, true)->str, ['{', ';'])) # test no curly
            $dar = 0;
    }
#.whitespace_after

#.whitespace_both
- on: in_array($y->tok ?: $y->str, $this->_ws_both, true)
  do: $line .= " $y->str ";
#.whitespace_both

#.comments
- on: $y->com
  do: |
    $nl = 1 & $y->com;
    $nl ? $put("$y->str\n") : ($line .= $y->str);

  #  if ('' === trim($line) && $out && $out[-1] == "\n" && '' !== $line) {
  #      $out = substr($out, 0, -1) . " " . trim($y->str) . "\n";
  #      $put('');
  #  } else $put("\n", trim($y->str));//$line .= $y->str;
#.comments
