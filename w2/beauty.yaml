
#.nice_php ///////////////////////////////////////////////////////////////////////////////////
body:
  rules:
    - on: T_OPEN_TAG == $y->tok
      do: |
        $put(trim($y->str) . "\n\n");
        $in_php = true;

    - on: in_array($y->tok, [T_HALT_COMPILER, T_CLOSE_TAG])
      do: |
        $line .= $y->str;
        $in_php = false;

    - on: in_array($y->tok, $this->_space_after)
      do: |
        $line .= $y->str . ' ';
        if (in_array($y->tok, $this->_control)) {
            $dar = $this->get_close($y, $y->new);
            if (in_array($this->tok($dar, true)->str, ['{', ';'])) # test no curly
                $dar = 0;
        }

    - on: in_array($y->tok ?: $y->str, $this->_space_op, true)
      do: $line .= " $y->str ";

    - on: $oc || ',' == $y->str
      do: |
        if ($at) {
            if ($oc > 0)
                return [$y, $out . $line];
            $line .= ',' == $y->str ? ', ' : $y->str;
        } else {
            $y->len = strlen($line);
            $line .= $this->open_close($oc, $y, $pv->tok ?: $pv->str, $depth, $put);
            if ($dar == $y->i) {
                $depth++;
                $put("\n");
                $dec = true;
            }
        }
    - on: ':' == $y->str && '?' == $pv->str
      do: $line .= ": ";

    - on: '}' == $pv->str && $alfa($y->str[0])
      do: $put("\n\n", $y->str);

    - on: ';' == $y->str
      do: |
        if ($dec) {
            $dec = false;
            $depth--;
        }
        $this->in_par ? ($line .= "; ") : $put(";\n");

    - on: in_array($y->tok, [T_COMMENT, T_DOC_COMMENT])
      do: |
        if ('' === trim($line) && $out && $out[-1] == "\n" && '' !== $line) {
            $out = substr($out, 0, -1) . " " . trim($y->str) . "\n";
            $put('');
        } else $put("\n", trim($y->str));//$line .= $y->str;

    - on: 1
      do: |
        if ($alfa($pv->str[-1]) && $alfa($y->str[0]) || T_RETURN == $pv->tok)
            $line .= ' ';
        $line .= $y->str;


head:
  param: $at
  code: |
    $depth = $dar = $dec = $in_php = 0;
    $out = $line = '';
    $put = function ($s1, $s2 = '') use (&$out, &$line, &$depth) {
        '' === $s1 or $out .= $line . $s1;
        $line = str_pad('', $depth * $this->tab) . $s2;
    };
    $alfa = fn($chr) => preg_match("/[a-z_\d\$]/i", $chr);

    for ($y = $pv = $this->tok($at); $y; $y = $y->new) {
        $y->new = $this->tok($y->i + 1);
        if (T_WHITESPACE == $y->tok)
            continue;
        if ($at && strlen($out . $line) > 120)/////////
            return [$y, $out . $line];
        $oc = $this->bracket($y);
        if ($this->in_str) {
            $line .= $y->str;
            continue;
        }

        if (in_array($y->tok, $this->_space_befor))
            $y->str = ' ' . $y->str;
        if ('}' == $pv->str && in_array($y->tok, $this->_nline_befor))
            $put("\n");
tail:
  code: |
    $pv = $y;
    }
    return $out . $line . ($in_php ? "\n" : '');
#.nice_php


#.nice_php_array ///////////////////////////////////////////////////////////////////////////////////
space_after: [$T_ECHO, $T_IF, $T_ELSEIF, $T_FOR, $T_WHILE, $T_FOREACH, $T_CATCH, $T_SWITCH, $T_LIST, $T_DO, $T_CASE]

space_befor: [$T_ELSEIF, $T_ELSE, $T_CATCH]

nline_befor: [$T_IF, $T_FOR, $T_WHILE, $T_FOREACH, $T_SWITCH, $T_LIST, $T_DO]

space_op: [
  =, /, %, *, ., >, <, ?, :, +, -,
  $T_LOGICAL_AND, $T_LOGICAL_OR, $T_LOGICAL_XOR,
  $T_AND_EQUAL, $T_BOOLEAN_AND, $T_BOOLEAN_OR, $T_COALESCE_EQUAL, $T_COALESCE, $T_CONCAT_EQUAL, $T_DIV_EQUAL,
  $T_DOUBLE_ARROW, $T_IS_EQUAL, $T_IS_IDENTICAL, $T_IS_NOT_IDENTICAL, $T_IS_GREATER_OR_EQUAL, $T_IS_NOT_EQUAL,
  $T_IS_SMALLER_OR_EQUAL, $T_MINUS_EQUAL, $T_MOD_EQUAL, $T_MUL_EQUAL, $T_OR_EQUAL, $T_PLUS_EQUAL, $T_POW, $T_POW_EQUAL,
  $T_SL, $T_SL_EQUAL, $T_SPACESHIP, $T_SR, $T_SR_EQUAL, $T_XOR_EQUAL
]

control: [$T_IF, $T_FOR, $T_FOREACH, $T_WHILE]

curly_reason: [
  $T_NAMESPACE, $T_USE,
  $T_IF, $T_ELSEIF, $T_ELSE,
  $T_FUNCTION, $T_CLASS, $T_INTERFACE, $T_TRAIT, $T_ENUM,
  $T_FOR, $T_FOREACH, $T_WHILE, $T_SWITCH, $T_DO,
  $T_TRY, $T_CATCH, $T_FINALLY
]
#.nice_php_array

~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# add T_MATCH
$T_DECLARE, 
T_ATTRIBUTE $T_ARRAY,
T_ENUM T_MATCH

T_ENDDECLARE
T_ENDIF T_ENDFOR T_ENDFOREACH T_ENDWHILE T_ENDSWITCH
#space_amp: [$T_FUNCTION]


#.test
head:
  param: $at

body:
  code: |
    return $at . $this->tab;
#.test
