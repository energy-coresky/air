#.yaml ///////////////////////////////////////////////////////////////////////////////////////
#._
+ @inc(.) ~/assets/database.yaml
#._

# ////////////////////////////////////////////////////////////////////////////////////////////
#.nice_php ///////////////////////////////////////////////////////////////////////////////////
body:
  rules:
    + @inc(.kw_array)
    + @inc(.tag_rules)
    + @inc(.casecolon)
    + @inc(.semicolon)
    + @inc(.ampersand)
    + @inc(.question)
    + @inc(.equals_sign)
    + @inc(.whitespace_after)
    + @inc(.whitespace_both)
    + @inc(.comments)
    + @inc(.brackets_or_comma)
    default: |
        isset($pv->com) or $pv->com=0;
        if (!$pv->com && $alfa($pv->str[-1]) && $alfa($y->str[0]) || T_RETURN == $pv->tok)
            $line .= ' ';
        $line .= $y->str;
head:
  param: $at, $to = 0
  code: |
    $depth = $dar = $d1 = $d2 = $in_php = $case = 0;
    $out = $line = $last_pv_semi ='';
    $put = function ($s1, $s2 = '') use (&$out, &$line, &$depth) {
        '' === $s1 or $out .= $line . $s1;
        $line = str_pad('', $depth * $this->tab) . $s2;
    };
    $alfa = fn($chr) => preg_match("/[a-z_\d\$]/i", $chr);

    for ($y = $pv = $this->tok($at); $y; $y = $y->new) {
        if (($y->new = $this->tok($y->i + 1)) && T_WHITESPACE == $y->new->tok)
            $y->new = $this->tok($y->i + 2); # next is NOT WHITESPACE

        if ($y->com = in_array($y->tok, $this->_comments)) {
            $c2 = $y->str[1] ?? '#';
            $y->com = '[' == $c2 ? 5 : ('*' == $c2 && '/' == $y->str[0] ? 2 : 1); # (->com & 1) - is nl required
            $y->str = rtrim($y->str); # (->com == 5) - attribute, nl required
            if (2 == $y->com && (strpos($y->str, "\n") || '' === $line))
                $y->com = 3; # multiline comment
        }

        $oc = $this->bracket($y);
        if ($this->in_str) {
            $line .= $y->str;
            continue;
        }

        if (in_array($y->tok, $this->_ws_head)) {
            $y->str = ' ' . $y->str;
        }
        if ('}' == $pv->str && isset($pv->reason) && !in_array($y->tok ?: $y->str, $this->_not_nl_after_curly)) {
            $put(in_array($pv->reason, $this->_double_nl_after) ? "\n\n" : "\n");
        }
        if (';' == $pv->str && in_array($y->tok, $this->_semicolon_prev)) {
            $last_pv_semi == $y->tok or $line = '' or $put("\n");
            $last_pv_semi = $y->tok;
        }

tail:
  code: |
    $pv = $y;
    }
    return $out . $line . ($in_php ? "\n" : '');
#.nice_php

#.ary_nice_php ///////////////////////////////////////////////////////////////////////////////////
+ @preflight |
  $array['not_open_curly'] = [
    T_NULLSAFE_OBJECT_OPERATOR => T_OBJECT_OPERATOR,
    T_NAME_QUALIFIED => T_NS_SEPARATOR,
  ];
  foreach ($array as $key => $val)
      PHP::$data->{$key} = $val;

not_nl_after_curly: [
  ',', '(', ')', '[', ']', '{', '}', ;,
  $T_ELSE, $T_ELSEIF, $T_CATCH, $T_FINALLY
]
ws_head: [$T_ELSE, $T_CATCH]
ws_tail: [@@inc(.loops), $T_IF, $T_CATCH, $T_ECHO, $T_MATCH, $T_LIST, $T_DO]
ws_both: [
  @@inc(.logic), @@inc(.bools), @@inc(.op_eq), @@inc(.op_is), @@inc(.shift),
  $T_DOUBLE_ARROW, $T_ELSEIF, $T_POW,
  /, %, *, ., >, <, +, -
]
semicolon_prev: [@@inc(.modifiers), $T_CONST, $T_USE, $T_FUNCTION]
double_nl_after: [@@inc(.newdn), $T_NAMESPACE]
control: [$T_IF, @@inc(.loops)]
comments: @inc(.com3)
curly_reason: [
  $T_DECLARE, $T_NAMESPACE, $T_USE, $T_SWITCH, $T_MATCH, $T_DO,
  @@inc(.loops), @@inc(.ifels), @@inc(.newdn), @@inc(.try)
]
#.ary_nice_php

# =====================================================================================
# ================================           RULES           ==========================
# =====================================================================================
#.tag_rules
- on: T_OPEN_TAG == $y->tok
  do: |
    $in_php = true;
    $y->i ? ($line .= "$y->str ") : $put(trim($y->str) . "\n\n");

- on: in_array($y->tok, [T_HALT_COMPILER, T_CLOSE_TAG])
  do: |
    $line .= $y->str;
    $in_php = false;
#.tag_rules

#.kw_array
- on: T_ARRAY == $y->tok && ($new = $this->tok($y->i, true)) && '(' == $new->str
  do: |
    $new->str = '['; // modify source
    $x = $this->x($new->i);      // get "(" x-data
    $this->tok[$x->close] = ']'; // set ")" to "]" from open data
    $this->tok[$y->i] = [T_COMMENT, '/*']; // dummy comment
    continue; // skip T_ARRAY
#.kw_array

#.question
- on: '?' == $y->str
  do: |
    ':' == $y->new->str ? ($line .= ' ?') : ($line .= ' ? ');
#.question

#.casecolon
- on: ($x = ':' == $y->str) || in_array($y->tok, [T_SWITCH, T_CASE, T_DEFAULT])
  do: |
    if ($case) { # colon
        $case = 0;
        $d2 = ++$depth;
        $put(":\n");
    } elseif ($x) { # colon also
        $line .= '?' == $pv->str ? ': ' : ' : ';
    } elseif (T_SWITCH == $y->tok) {
        $line .= $y->str . ' ';
        $d2 = 0;
    } else {
        $case = 2;
        if ($d2) {
            $depth--;
            $put('', $y->str);
        } else {
            $line .= $y->str;
        }
        T_DEFAULT == $y->tok or $line .= ' ';
        $d2 = 0;
    }
#.casecolon

#.semicolon
- on: ';' == $y->str
  do: |
    if ($d1) {
        //$d1--;
        $depth -= $d1;
        $d1 = 0;
    }
    $this->in_par ? ($line .= "; ") : $put(";\n");
#.semicolon

#.ampersand
- on: '&' == $y->str
  do: |
    $new = $this->tok($y->i, true);
    if ($alfa($pv->str[-1]))
        $y->str = ' ' . $y->str;
    if ($alfa($new->str[0]) && T_FUNCTION != $pv->tok && 
        (T_VARIABLE != $new->tok || '=' == $pv->str)
    )
        $y->str .= ' ';

        $line .= $y->str;
#.ampersand

#.equals_sign
- on: '=' == $y->str
  do: |
    $new = $this->tok($y->i, true);
    $line .= " =" . ('&' == $new->str ? '' : ' ');
#.equals_sign

#.whitespace_after
- on: in_array($y->tok, $this->_ws_tail)
  do: |
    $line .= $y->str . ' ';
    if (in_array($y->tok, $this->_control)) {
        $dar = $this->get_close($y, $y->new);
        if (in_array($this->tok($dar, true)->str, ['{', ';'])) # test no curly
            $dar = 0;
    }
#.whitespace_after

#.whitespace_both
- on: in_array($y->tok ?: $y->str, $this->_ws_both, true)
  do: $line .= " $y->str ";
#.whitespace_both

#.comments
- on: $y->com
  do: |
    if ('/*' == $y->str) // dummy comment
        continue;
    $ok_com = function () use ($out, $y) {
        $pos = strrpos($out, "\n", -2);
        if (!$len = strlen(trim(substr($out, $pos)))) // empty prev line
            return false;
        return $len + strlen($y->str) < 90 && $len > 3;
    };
    if ('' === trim($line) && !$pv->com && (!$y->new || !in_array($y->new->tok, $this->_comments)) && $ok_com()) {
        $out = substr($out, 0, -1) . " $y->str\n";
        $put('');
    } elseif (1 & $y->com || T_DOC_COMMENT == $y->tok) { # new line
        $put("$y->str\n");
    } else {
        $line .= $y->str;
    }
#.comments

#.brackets_or_comma
- on: $oc || ',' == $y->str
  do: |
    if ($at) {
        if ($oc > 0) { // opening
            $x = $this->x($y->i);
            if ($x->len > 80 || '{' == $y->str)
                return [$y, $out . $line, $x];
        } elseif ($y->i >= $to) { // close or comma
            return [$y, $out . $line, false];
        }
        $line .= $y->str . ($oc ? '' : ' ');
    } else {
        $y->line =& $line;
        $line .= $this->indents($oc, $y, $pv->tok ?: $pv->str, $depth, $put);
        if ($dar == $y->i) {
            $depth++;
            $put("\n");
            $d1++;
        }
    }
#.brackets_or_comma
