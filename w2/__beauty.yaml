#.yaml ///////////////////////////////////////////////////////////////////////////////////////
#._
+ @inc(.) ~/assets/database.yaml
#._

# ////////////////////////////////////////////////////////////////////////////////////////////
#.nice_php ///////////////////////////////////////////////////////////////////////////////////
body:
  rules:
    + @inc(.tag_rules)        # <? ?>
    + @inc(.multilines)       # <div, "A\nB"
    + @inc(.elseifelse)       # elseif else
    + @inc(.endword)          # endif,..
    + @inc(.casecolon)        # : switch case default
    + @inc(.chars)            # ; & ? =
    + @inc(.comments)         # //,..
    + @inc(.whitespace_both)  # + - += -= => ..
    + @inc(.whitespace_after) # for,.. if catch echo match do
    + @inc(.brackets_or_comma) # {[(,)]}
    default: |
      if ($line !== '' && $alfa($line[-1]) && $alfa($y->str[0]))
          $line .= ' ';
      $line .= $y->str;
head:
  param: $at, $to = 0
  code: |
    $depth = $dar = $d1 = $d2 = $s5 = $c7 = $in_php = 0;
    $out = $line = $last_pv_semi = '';
    $put = function ($s1, $s2 = '') use (&$out, &$line, &$depth) {
        '' === $s1 or $out .= $line . $s1;
        $line = str_pad('', $depth * $this->tab) . $s2;
    };
    $alfa = fn($chr) => preg_match("/[a-z_\d\$]/i", $chr);
    $fnew = fn($y) => is_int($y) ? $this->tok($y, true) : ($y->new->com ? $this->tok($y->new->i, true) : $y->new);
    $stk = [];
    $reset_stk = function ($y, $ary = []) use (&$stk, &$depth, &$d1, &$d2) {
        if (in_array($y->tok ?: $y->str, $ary + [99 => ';', T_ELSE, T_ELSEIF], true))
            return;
        array_splice($stk, $d2);
        [$depth, $d1] = [$depth - $d1, 0];
    };

    for ($y = $pv = $this->tok($at); $y; $y = $y->new) {
        if (($y->new = $this->tok($y->i + 1)) && T_WHITESPACE == $y->new->tok)
            $y->new = $this->tok($y->i + 2); # next is NOT WHITESPACE
        if ($y->new)
            $y->new->com = in_array($y->new->tok, $this->_comments);
        $oc = $this->int_bracket($y, true);
        if ($this->in_str) {
            $line .= $y->str;
            continue;
        }

        if ($y->com) {
            $c2 = $y->str[1] ?? '#';
            $y->com = '[' == $c2 ? 5 : ('*' == $c2 && '/' == $y->str[0] ? 2 : 1); # (->com & 1) - is nl required
            $y->str = rtrim($y->str); # (->com == 5) - attribute, nl required
            if (2 == $y->com && (strpos($y->str, "\n") || '' === $line))
                $y->com = 3; # multiline comment
        }

        if (T_RETURN == $pv->tok && ';' != $y->str)
            $line .= ' ';
        if (')' == $pv->str && T_USE == $y->tok)
            $y->str = " $y->str ";
        if (in_array($y->tok, [T_CATCH, T_FINALLY]) || T_WHILE == $y->tok && '}' == $pv->str)
            $y->str = ' ' . $y->str;
        if ('}' == $pv->str && $pv->len && !in_array($y->tok ?: $y->str, $this->_not_nl_after_curly))
            $put(in_array($pv->reason, $this->_double_nl_after) ? "\n\n" : "\n");

        if (';' == $pv->str && in_array($y->tok, $this->_semicolon_prev)) {
            $last_pv_semi == $y->tok or $line = '' or $put("\n");
            $last_pv_semi = $y->tok;
        }

tail:
  code: |
    end:
    unset($new);
    $pv = $y;
    }
    return $out . $line . ($in_php ? "\n" : '');
#.nice_php

#.ary_nice_php ///////////////////////////////////////////////////////////////////////////////////
+ @preflight |
  $array['not_nl_curly'] = [ # step1,2
    T_NULLSAFE_OBJECT_OPERATOR => T_OBJECT_OPERATOR,
    T_NAME_QUALIFIED => T_NS_SEPARATOR,
  ];
  foreach ($array as $key => $val)
      PHP::$data->{$key} = $val;

tokens_ign: [$T_WHITESPACE, $T_COMMENT, $T_DOC_COMMENT] # step1
curly_reason: [ # step1
  $T_DECLARE, $T_NAMESPACE, $T_USE, $T_SWITCH, $T_MATCH, $T_DO,
  @@inc(.loops), @@inc(.ifels), @@inc(.newdn), @@inc(.try)
]
optim_key: [ # step1
  @@inc(.com3), $T_WHITESPACE, $T_VARIABLE,
  $T_LNUMBER, $T_DNUMBER, $T_CONSTANT_ENCAPSED_STRING
]
not_nl_after_curly: [
  ',', '(', ')', ']', '}', ;,
  $T_CATCH, $T_FINALLY, $T_ELSE, $T_ELSEIF, $T_WHILE
]
ws_tail: [@@inc(.loops), $T_IF, $T_CATCH, $T_ECHO, $T_MATCH]
ws_both: [
  /, %, *, ., >, <, +, -, $T_DOUBLE_ARROW, $T_POW,
  @@inc(.logic), @@inc(.bools), @@inc(.op_eq), @@inc(.op_is), @@inc(.shift)
]
semicolon_prev: [@@inc(.modifiers), $T_CONST, $T_USE, $T_FUNCTION]
double_nl_after: [@@inc(.newdn), $T_NAMESPACE]
ctrl_d1: [@@inc(.loops), $T_IF]
multilines: [$T_INLINE_HTML, $T_CONSTANT_ENCAPSED_STRING]
comments: @inc(.com3)
endword: @inc(.ends)
altsyntax: [@@inc(.loops), $T_IF, $T_ELSEIF, $T_SWITCH, $T_DECLARE]
no_nl_before: [$T_TRY, $T_DO, $T_SWITCH, $T_MATCH, '{', ';', ':']
#.ary_nice_php

# =====================================================================================
# ================================           RULES           ==========================
# =====================================================================================
#.tag_rules
- on: T_OPEN_TAG == $y->tok
  do: |
    $y->i ? ($line .= $y->str) : $put(trim($y->str) . "\n\n");
    $in_php = true;
- on: T_CLOSE_TAG == $y->tok
  do: |
    '' === $line || ' ' == $line[-1] or $y->str = " $y->str";
    if ("\n" == $y->str[-1]) {
        $put($y->str);
    } else {
        $line .= $y->str;
    }
    $in_php = false;
- on: T_HALT_COMPILER == $y->tok
  do: |
    $line .= $y->str;
    $in_php = false;
    $this->in_html = 1;
#.tag_rules

#.multilines
- on: in_array($y->tok, $this->_multilines)
  do: |
    if (T_INLINE_HTML == $y->tok)
        $this->in_html = 1;
    if (false !== ($pos = strrpos($y->str, "\n"))) {
        $put(substr($y->str, 0, $pos + 1));
        $line = substr($y->str, $pos + 1);
    } else {
        $line .= $y->str;
    }
#.multilines

#.elseifelse
- on: ($else = T_ELSE == $y->tok) || T_ELSEIF == $y->tok
  do: |
    if ($_ = $d1) {
        [$depth, $d1] = end($stk);
        if ($d1 < $_ && '}' == $pv->str)
            $put("\n");
        $else && array_pop($stk);
    }

    if ($this->in_html) {
        $line .= $else ? $y->str : "$y->str ";
    } else {
        $new = $fnew($y);
        $else or $new = $fnew($close = $new->close);
        if (':' == $new->str) {
            $depth--;
            $put('' === trim($line) ? '' : "\n", $else ? $y->str : "$y->str ");
        } elseif (in_array($new->tok ?: $new->str, $this->_no_nl_before)) {//'{' == $new->str
            '' === trim($line) ? $put('') : ($line .= ' ');
            $line .= $else && !$new->tok ? $y->str : "$y->str ";
        } elseif ($else) {
            $put('' === trim($line) ? '' : "\n", $y->str);
            $depth++;
            $d1++;
            $put("\n");
        } else { # T_ELSEIF
            $line .= "$y->str ";
            $dar = $close;
        }
    }
#.elseifelse

#.endword
- on: in_array($y->tok, $this->_endword)
  do: |
    if ($swt = T_ENDSWITCH == $y->tok)
        $depth--;
    if ($this->in_html && !$swt) {
        $line .= $y->str;
    } else {
        $this->in_html or $depth--;
        $put('' === trim($line) ? '' : "\n", $y->str);
    }
#.endword

#.casecolon
- on: ':' == $y->str
  do: |
    if ($c7) {
        $c7 = false;
        $s5 = ++$depth;
        $put(":\n");
    } elseif (T_ELSE == $pv->tok) {
        if (!$this->in_html)
            goto ifels;
        $line .= ':';
    } elseif (')' == $pv->str) {
        if (isset($pv->reason) && in_array($pv->reason, $this->_altsyntax) && !$this->in_html) {
            ifels:
            ++$depth;
            $put(":\n");
        } else {
            $line .= ' : ';
        }
    } else {
        $line .= '?' == $pv->str ? ': ' : ' : ';
    }
- on: in_array($y->tok, [T_SWITCH, T_CASE, T_DEFAULT])
  do: |
    if (T_SWITCH == $y->tok) {
        $line .= $y->str . ' ';
    } else {
        $c7 = true;
        if ($s5) {
            $depth--;
            $put('', $y->str);
        } else {
            $line .= $y->str;
        }
        T_DEFAULT == $y->tok or $line .= ' ';
    }
    $s5 = 0;
#.casecolon

#.chars
- on: ';' == $y->str
  do: |
    if ($this->in_html || $this->in_par) {
        $line .= '; ';
        goto end;
    } elseif ($d1 && $y->new) {
        $reset_stk($fnew($y));
    } else {
        [$depth, $d1] = [$depth - $d1, 0];
    }
    $put(";\n");
- on: '&' == $y->str
  do: |
    if ($alfa($pv->str[-1]))
        $y->str = ' ' . $y->str;
    if ($alfa($y->new->str[0]) && T_FUNCTION != $pv->tok && (T_VARIABLE != $y->new->tok || '=' == $pv->str))
        $y->str .= ' ';
    $line .= $y->str;
- on: '?' == $y->str
  do: |
    ':' == $y->new->str ? ($line .= ' ?') : ($line .= ' ? ');
- on: '=' == $y->str
  do: |
    $line .= ' =' . ('&' == $y->new->str ? '' : ' ');
#.chars

#.comments
- on: $y->com
  do: |
    //if ('/*' == $y->str) // dummy comment
    //    continue;
    $ok_com = function () use (&$out, &$y) {
        $pos = strrpos($out, "\n", -2);
        if (!$len = strlen(trim(substr($out, $pos)))) # empty prev line
            return false;
        return $len + strlen($y->str) < 90 && $len > 3;
    };
    if ('' === trim($line) && !$pv->com && (!$y->new || !in_array($y->new->tok, $this->_comments)) && $ok_com()) {
        $out = substr($out, 0, -1) . " $y->str\n";
        $put('');
    } elseif (1 & $y->com || T_DOC_COMMENT == $y->tok) { # new line
        $put("$y->str\n");
    } else {
        $line .= $y->str;
    }
#.comments

#.whitespace_both
- on: in_array($y->tok ?: $y->str, $this->_ws_both, true)
  do: $line .= $line === '' || ' ' == $line[-1] ? "$y->str " : " $y->str ";
#.whitespace_both

#.whitespace_after
- on: in_array($y->tok, $this->_ws_tail)
  do: |
    $line .= $y->str . ' ';
    if (in_array($y->tok, $this->_ctrl_d1)) {
        $new = $fnew($dar = $fnew($y)->close);
        if (in_array($new->tok ?: $new->str, $this->_no_nl_before)) { # test no nl
            $dar = 0;
        } elseif (!$this->in_html && T_IF == $y->tok) {
            $stk[] = [$depth, $d1, 0, 0];
        }
    }
#.whitespace_after

#.brackets_or_comma
- on: $oc || ',' == $y->str
  do: |
    if ($at) {
        if ($oc > 0) { # open
            if ($y->len > 80 || '{' == $y->str)
                return [$y, $out . $line];
        } elseif ($y->i >= $to) { # close or comma
            return [$y, $out . $line];
        }
        $line .= $y->str . ($oc ? '' : ' ');
    } else {
        if ('(' == $y->str && in_array($pv->tok, $this->_altsyntax)) {
            [, $close, $reason] = $this->x[$y->i];
            $this->x[$close] = [0, 0, $reason];
        }
        $y->line =& $line;
        $line .= $this->indents($oc, $y, $pv->tok, $depth, $put);
        if ($dar == $y->i) { # )
            $depth++;
            $put("\n");
            $d1++;
        } elseif ($d1 && '{' == $y->str && in_array($y->reason, $this->_curly_reason)) {
            $stk[] = [$depth - 1, $d1, $d2, $y->close];
            [$d1, $d2] = [0, count($stk)];
        } elseif ($stk && end($stk)[3] == $y->i) {
            [$depth, $d1, $d2] = array_pop($stk);
            in_array($y->reason, [T_TRY, T_DO]) or
                $y->new && $reset_stk($fnew($y), [T_FINALLY]);
        }
    }
#.brackets_or_comma
